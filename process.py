# ---------------------------------------------------------------------------
# process.py
# Created on: 2011-01-20 15:45:10.00000
#   (generated by ArcGIS/ModelBuilder)
# Description: 
# ---------------------------------------------------------------------------

# Import arcpy module
import arcpy
import os
import subprocess
import tempfile
import gc
import random

def remove_shapefile(filename):
    """Removes a shapefile and all its associated files. The given filename can be any of the files
    include in the shapefile, but will normally be the .shp file"""
    extensions = [".dbf", ".sbn", ".sbx", ".shp", ".shp.xml", ".shx"]

    no_ext, ext = os.path.splitext(filename)

    for extension in extensions:
        filepath = no_ext + extension
        if os.path.isfile(filepath):
            os.remove(filepath)

def create_temp_filename(filename):
    """Create a filename which can then be used as a temporary file.
    Simply adds the filename given to the temporary folder path on the OS,
    and adds a random number to the end to make it fairly unique."""

    # Get the temporary path for the OS we're running on
    tempdir = tempfile.gettempdir()

    base, ext = os.path.splitext(filename)

    filename = base + str(random.randint(1,500)) + ext

    filepath = os.path.join(tempdir, filename)

    # If the file already exists then remove it
    if os.path.isfile(filepath):
        remove_shapefile(filepath)

    return filepath

def add_joining_lines(input_lines, output_lines, max_distance):
    """Add lines between the ends of each of the input lines if the distance is
    less than max_distance. Store these new lines in output_lines"""
    
    print "Starting add_joining_lines"
    
    points = create_temp_filename("AJL_Points.shp")

    if os.path.isfile(output_lines):
        remove_shapefile(output_lines)

    arcpy.CreateFeatureclass_management(os.path.dirname(output_lines), os.path.basename(output_lines), "POLYLINE")

    # Convert the lines to points at each end
    arcpy.FeatureVerticesToPoints_management(input_lines,points,"BOTH_ENDS")

    # Generate the near table
    arcpy.Near_analysis(points, points, max_distance, True, True)

    # Get the SearchCursor to allow us to iterate over the points
    points_rows = arcpy.SearchCursor(points)

    # Also get an InsertCursor to allow us to add to the lines
    output_rows = arcpy.InsertCursor(output_lines)

    # Get the shape field name
    points_shape_name = arcpy.Describe(points).shapeFieldName

    # For each row (that is, each line in the input dataset)
    for row in points_rows:
        # Get the nearest point found
        new_x = row.getValue("NEAR_X")
        new_y = row.getValue("NEAR_Y")

        # If one or other of them is not valid then continue to next iteration
        if new_x == -1 or new_y == -1:
            continue

        # Get the FID of the line that this point was originally part of
        orig_fid = row.getValue("ORIG_FID")

        # Get the details of the input lines file (OID field name and the Shape field name)
        desc = arcpy.Describe(input_lines)
        oid_field = desc.OIDFieldName
        line_shape_name = desc.shapeFieldName

        # Construct the SQL WHERE clause to select the original line corresponding to the selected
        # points
        where_clause = arcpy.AddFieldDelimiters(input_lines, oid_field) + " = " + str(orig_fid)
        orig_rows = arcpy.SearchCursor(input_lines, where_clause)

        # Get the X and Y values of the current point
        part = row.getValue(points_shape_name).getPart()
        current_x = part.X
        current_y = part.Y

        # There will only be one record returned from the SQL statement above
        # so just get it (don't bother with a loop)
        line_row = orig_rows.next()

        # Get the first and last points of the selected line
        geom = line_row.Shape
        firstp = geom.firstPoint
        lastp = geom.lastPoint

        # Check to see if we are trying to connect one end of a line with the other end
        # If so, continue to the next loop iteration (that is, the next point)
        # NB: Two if statements are required as it needs to be checked both ways around
        if (current_x == firstp.X and current_y == firstp.Y) and (new_x == lastp.X and new_y == lastp.Y):
            continue
        elif (current_x == lastp.X and current_y == lastp.Y) and (new_x == firstp.X and new_y == firstp.Y):
            continue

        # If we've got to here then we want to create the line (we'll have 'continue'd before this
        # if there was a problem with the line. So...
        
        # Add the points to a new array of points for the line
        lineArray = arcpy.Array()

        first = arcpy.Point(X=current_x, Y=current_y)
        last = arcpy.Point(X=new_x, Y=new_y)

        lineArray.add(first)
        lineArray.add(last)    

        # Insert the new line into the dataset
        feat = output_rows.newRow()
        feat.shape = lineArray
        output_rows.insertRow(feat)

        del orig_rows
        del line_row


    # Clean up
    del output_rows
    del feat
    del points_rows
    del row

    gc.collect()

def intersect_line_and_raster(input_lines, input_raster):
    """Run the Geospatial Modelling Tools function isectlinerst to get summary statistics about the raster
    cells under a polyline"""
    
    cmd = "C:\\GME\\SEGME.exe -c isectlinerst(in=\\\"" + input_lines + "\\\", raster=\\\"" + input_raster + "\\\", prefix=\\\"RST_\\\")"

    # The GME documentation suggests using system(), but the Python docs state that this is
    # the new equivalent of system.
    output = subprocess.Popen(cmd, stdout=subprocess.PIPE).communicate()


def add_and_check_joining_lines(input_lines, input_raster, distance, dem_threshold):
    """Adds joining lines between the input lines, given the distance,
    if the lines don't have too much variance in the DEM under them (in this
    case, it will stop lines that go across interdunes"""

    temp_lines = create_temp_filename("TempLines.shp")
    print temp_lines
    output_file = create_temp_filename("Output.shp")
    
    # Create the joining lines
    add_joining_lines(input_lines, temp_lines, distance)

    # Add fields to the lines based on the raster underneath
    intersect_line_and_raster(temp_lines, input_raster)

    # Create a new calculated field for the difference between the mean and the min
    arcpy.AddField_management(temp_lines, "Calc", "FLOAT")

    arcpy.CalculateField_management(temp_lines, "Calc", "[RST_LWM]- [RST_MIN]")

    # Make the joining lines a layer so we can select from it
    arcpy.MakeFeatureLayer_management(temp_lines, "tempLayer")

    # Construct the SQL WHERE clause to get what we want
    where_expression = arcpy.AddFieldDelimiters("tempLayer", "Calc") + " > " + str(dem_threshold)
    
    # Select based on the SQL WHERE clause we just constructed
    arcpy.SelectLayerByAttribute_management("tempLayer", "NEW_SELECTION", where_expression)

    # If we have some features selected then delete them, as they're the
    # ones we don't want
    if arcpy.GetCount_management("tempLayer") > 0:
        arcpy.DeleteFeatures_management("tempLayer")

    arcpy.Merge_management([input_lines, temp_lines], output_file)

    return output_file

def CalculateStatistics(inputData, FieldName):
    temp_table = create_temp_filename("Table")
    # Execute the Summary Statistics tool using the MEAN, SUM and COUNT options
    arcpy.Statistics_analysis(inputData, temp_table, FieldName + " MEAN;" + FieldName + " SUM;" + FieldName + " COUNT;" + FieldName + " MIN;" + FieldName + " MAX;" + FieldName + " STD;")
    # Get a list of fields from the new in-memory table.
    flds = arcpy.ListFields(temp_table)
    # Retrieve the field with the mean value.
    for fld in flds:
        if fld.name.__contains__("MEAN_"):
            # Open a Search Cursor using field name.
            rows = arcpy.SearchCursor(temp_table, "", "", fld.name)
            #Get the first row and mean value.
            row = rows.next()
            mean = row.getValue(fld.name)
        elif fld.name.__contains__("SUM_"):
            # Open a Search Cursor using field name.
            rows = arcpy.SearchCursor(temp_table, "", "", fld.name)
            #Get the first row and mean value.
            row = rows.next()
            total = row.getValue(fld.name)
        elif fld.name.__contains__("COUNT_"):
            # Open a Search Cursor using field name.
            rows = arcpy.SearchCursor(temp_table, "", "", fld.name)
            #Get the first row and mean value.
            row = rows.next()
            count = row.getValue(fld.name)
        elif fld.name.__contains__("MAX_"):
            # Open a Search Cursor using field name.
            rows = arcpy.SearchCursor(temp_table, "", "", fld.name)
            #Get the first row and mean value.
            row = rows.next()
            maximum = row.getValue(fld.name)
        elif fld.name.__contains__("MIN_"):
            # Open a Search Cursor using field name.
            rows = arcpy.SearchCursor(temp_table, "", "", fld.name)
            #Get the first row and mean value.
            row = rows.next()
            minimum = row.getValue(fld.name)
        elif fld.name.__contains__("STD_"): 
           # Open a Search Cursor using field name.
            rows = arcpy.SearchCursor(temp_table, "", "", fld.name)
            #Get the first row and mean value.
            row = rows.next()
            std = row.getValue(fld.name)
    return [count, mean, total, maximum, minimum, std]

def PolylineToPoint_Centre(InputPolylines):
    OutputPoints = create_temp_filename("NN_Points.shp")

    arcpy.CreateFeatureclass_management(os.path.dirname(OutputPoints), os.path.basename(OutputPoints), "POINT")

    # Get the shape field name
    shape_name = arcpy.Describe(InputPolylines).shapeFieldName

    rows = arcpy.SearchCursor(InputPolylines)

    for row in rows:
        cur = arcpy.InsertCursor(OutputPoints)
        new_row = cur.newRow()

        # Get the shape object of the lines
        shape = row.getValue(shape_name)
        cent = shape.centroid

        point = arcpy.Point(cent.X, cent.Y)
        
        new_row.shape = point
        cur.insertRow(new_row)
        del new_row
    del rows
    del row
    return OutputPoints

print "Starting Main Processing Script"

### PARAMETERS HERE
input_file = "D:\\CrestsOutput_MaurWhole_Params2.tif"
output_file = "D:\MaurWhole_NonSmoothed_Params2_Again.shp"
input_dem = "D:\\Maur_DEM_Whole_NoGeoref.tif"
joining_first = 1
joining_second = 100
dem_threshold = 20
min_length = 100

### ArcGIS Environment Configuration
arcpy.env.overwriteOutput = True
arcpy.env.XYTolerance = 0.5

### Creating names for temporary files
OrigCrestVector = create_temp_filename("OrigCrestVector.shp")
UnsplitOutput1 = create_temp_filename("UnsplitOutput_1_.shp")
BeforeSubset = create_temp_filename("BeforeSubset.shp")

print "Converting Raster to Polyline"
# Process: Raster to Polyline
arcpy.RasterToPolyline_conversion(input_file, OrigCrestVector, "ZERO", "2", "SIMPLIFY", "Value")

print "Adding joining lines"
Joined = add_and_check_joining_lines(OrigCrestVector, input_dem, joining_first, dem_threshold)

# TODO: Replace with Dissolve with Single Part?
arcpy.UnsplitLine_management(Joined, UnsplitOutput1)

print "Adding joining lines"
Joined_2 = add_and_check_joining_lines(UnsplitOutput1, input_dem, joining_second, dem_threshold)

arcpy.UnsplitLine_management(Joined_2, output_file)

# Calculating the length of each line so we can remove the small ones
arcpy.AddField_management(output_file, "Length", "FLOAT")
arcpy.CalculateField_management(output_file, "Length", "!shape.length!", "PYTHON")

arcpy.MakeFeatureLayer_management(output_file, "BeforeSubsetLayer")
where_clause = arcpy.AddFieldDelimiters(output_file, "Length") + " < " + str(min_length)
arcpy.SelectLayerByAttribute_management("BeforeSubsetLayer", "NEW_SELECTION", where_clause)

# If we have some features selected then delete them, as they're the
# ones we don't want
if arcpy.GetCount_management("BeforeSubsetLayer") > 0:
    arcpy.DeleteFeatures_management("BeforeSubsetLayer")

remove_shapefile(OrigCrestVector)
remove_shapefile(UnsplitOutput1)
remove_shapefile(BeforeSubset)
remove_shapefile(Joined)
remove_shapefile(Joined_2)

print "Final vector output saved to: " + output_file

print "Calculating statistics"

# Get stats on the dune lengths and numbers
stats = CalculateStatistics(output_file, "Length")

print "Converting to points to calculate Nearest Neighbour"
NNPoints = PolylineToPoint_Centre(output_file)
# Do Nearest Neighbour calculation
arcpy.AverageNearestNeighbor_stats
nn_output = arcpy.AverageNearestNeighbor_stats(NNPoints, "Euclidean Distance", "false", "#")

n_dunes = stats[0]
mean_len = stats[1]
total_len = stats[2]
max_len = stats[3]
min_len = stats[4]
stdev_len = stats[5]

defect_dens = n_dunes / total_len

# Get out the individual parts of the Nearest Neighbour output
r_score = nn_output.getOutput(0)
z_score = nn_output.getOutput(1)
p_value = nn_output.getOutput(2)

# Create the CSV line ready to be appended
csv_array = []
output_stats = [input_file, n_dunes, mean_len, total_len, max_len, min_len, stdev_len, 0, 0, defect_dens, r_score, z_score, p_value]

for item in output_stats:
    csv_array.append(str(item))

csv_string = ",".join(csv_array)

print "-----"
print csv_string
print "-----"
print "Done"
